# Speaking CSharp (C#)

## Importing namespaces

``System`` is a namespace, which is like an address for a type.

``System.Console.WriteLine`` tells the compiler to look for a method named WriteLine in a type named **Console** in a namespace named **System**. To simplify our code, the Console Application project template for every version of .NET before 6.0 added a statement at the top of the code file to tell the compiler to always look in the System namespace for types that haven't been prefixed with their namespace, as shown in the following code:

```csharp
    using System; // import the System namespace
```

We call this *importing the namespace*. The effect of importing a namespace is that all available types in that namespace will be available to your program without needing to enter the namespace prefix and will be seen in **IntelliSense** while you write code.

## Implicitly and globally importing namespaces

Traditionally, every **.cs** file that needs to import namespaces would have to start with using statements to import those namespaces. Namespaces like ``System`` and ``System.Linq`` are needed in almost all .cs files, so the first few lines of every .cs file often had at least a few using statements, as shown in the following code:

```csharp
    using System;
    using System.Linq;
    using System.Collections.Generic;
```

C# 10 introduces some new features that simplify importing namespaces.

First, the global using statement means you only need to import a namespace in one .cs file and it will be available throughout all .cs files. You could put global using statements in the ``Program.cs`` file but I recommend creating a separate file for those statements named something like ``GlobalUsings.cs`` or ``GlobalNamespaces.cs``, as shown in the following code:

```csharp
    global using System;
    global using System.Linq;
    global using System.Collections.Generic;
```

Create a new Solution in Visual Studio. For example, ``HelloCS``.

Go to the **obj\Debug\net6.0** folder, and open the file named ``HelloCS.GlobalUsings.g.cs``.

The following file is automatically generated for you.

```csharp
    // <autogenerated />
    global using global::System;
    global using global::System.Collections.Generic;
    global using global::System.IO;
    global using global::System.Linq;
    global using global::System.Net.Http;
    global using global::System.Threading;
    global using global::System.Threading.Tasks;
```

You can add or remove global using statements by modifying the Solution's **.csproj** file.

```csharp
    <Project Sdk="Microsoft.NET.Sdk">

      <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net7.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
      </PropertyGroup>

      <ItemGroup>
        <Using Remove="System.Threading" />
        <Using Include="System.Numerics" />
      </ItemGroup>
    </Project>
```

By adding an **ItemGroup** section in our project we can modify the global usings. Now when you open the ``GlobalUsings`` file it will look like this.

```csharp
    // <auto-generated/>
    global using global::System;
    global using global::System.Collections.Generic;
    global using global::System.IO;
    global using global::System.Linq;
    global using global::System.Net.Http;
    global using global::System.Numerics;
    global using global::System.Threading.Tasks;
```

You can **disable** the implicitly imported namespaces feature for all SDKs by removing an entry in the project file, as shown in the following markup:

```csharp
    <ImplicitUsings>enable</ImplicitUsings>
```

## Verbs are methods

In English, verbs are doing or action words, like run and jump. In C#, doing or action words are called **methods**. There are hundreds of thousands of methods available to C#.

In C#, methods such as ``WriteLine`` change how they are called or executed based on the specifics of the action. This is called overloading. Consider the following example:

```csharp
    // outputs the current line terminator string
    // by default, this is a carriage-return and line feed
    Console.WriteLine();

    // outputs the greeting and the current line terminator string
    Console.WriteLine("Hello Ahmed");

    // outputs a formatted number and date and the current line terminator string
    Console.WriteLine("Temperature on {0:D} is {1}Â°C.", DateTime.Today, 23.4);
```

A different analogy is that some words are spelled the same but have different meanings depending on the context.

## Nouns are types, variables, fields, and properties

In English, nouns are names that refer to things. For example, Fido is the name of a dog. The word "dog" tells us the type of thing that Fido is, and so in order for Fido to fetch a ball, we would use his name.

In C#, their equivalents are types, variables, fields, and properties. For example:

* Animal and Car are types; they are nouns for categorizing things.
* Head and Engine might be fields or properties; nouns that belong to Animal and Car.
* Fido and Bob are variables; nouns for referring to a specific object.

There are tens of thousands of types available to C#, though have you noticed how I didn't say, "There are tens of thousands of types in C#?" The difference is subtle but important.

The language of C# only has a few keywords for types, such as string and int, and strictly speaking, C# doesn't define any types. Keywords such as string that look like types are **aliases**, which represent types provided by the platform on which C# runs.

It's important to know that C# cannot exist alone; after all, it's a language that runs on variants of .NET. In theory, someone could write a compiler for C# that uses a different platform, with different underlying types. In practice, the platform for C# is .NET, which provides tens of thousands of types to C#, including ``System.Int32``, which is the C# keyword alias int maps to, as well as many more complex types, such as ``System.Xml.Linq.XDocument``.

It's worth taking note that the term **type** is often confused with **class**. Have you ever played the parlor game Twenty Questions, also known as Animal, Vegetable, or Mineral? In the game, everything can be categorized as an animal, vegetable, or mineral. In C#, every type can be categorized as a class, struct, enum, interface, or delegate. As examples, the C# keyword string is a class, but int is a struct. So, it is best to use the term type to refer to both.

## Revealing the extent of the C# vocabulary

We know that there are more than 100 keywords in C#, but how many types are there? Let's write some code to find out how many types (and their methods) are available to C# in our simple console application.

Add the following using statement to the top of the code.

```csharp
    using System.Reflection;
```

 then.

```csharp
    static void Main(string[] args)
    {
        Assembly? assembly = Assembly.GetEntryAssembly();
    
        if (assembly == null) return;
    
        // loop through the assemblies that this app references
        foreach (AssemblyName name in assembly.GetReferencedAssemblies())
        {
            // load the assembly so we can read its details
            Assembly a = Assembly.Load(name);
    
            // declare a variable to count the number of methods
            int methodCount = 0;
    
            // loop through all the types in the assembly
            foreach (TypeInfo t in a.DefinedTypes)
            {
                // add up the counts of methods
                methodCount += t.GetMethods().Count();
            }
    
            // output the count of types and their methods
            Console.WriteLine("{0:N0} types with {1:N0} methods in {2} assembly.", arg0: a.DefinedTypes.Count(), arg1:methodCount, arg2: name.Name);
        }
    }
```

Results:

> 0 types with 0 methods in System.Runtime assembly.        
> 108 types with 1,141 methods in System.Linq assembly.     
> 46 types with 670 methods in System.Console assembly.

**Note:** Why does the ``System.Runtime`` assembly contain zero types? This assembly is special because it contains only type-forwarders rather than actual types. A type-forwarder represents a type that has been implemented outside of .NET or for some other advanced reason.

Add some other using statements into the ``Main()`` method.

```csharp
    System.Data.DataSet ds;
    HttpClient client;
```

Now, run the program again and you will get the following results.

> 0 types with 0 methods in System.Runtime assembly.        
> 400 types with 7,038 methods in System.Data.Common assembly.      
> 426 types with 4,613 methods in System.Net.Http assembly.     
> 108 types with 1,141 methods in System.Linq assembly.     
> 46 types with 670 methods in System.Console assembly.

Now, you have a better sense of why learning C# is a challenge, because there are so many types and methods to learn. Methods are only one category of a member that a type can have, and you and other programmers are constantly defining new types and members!

## Working with variables

All applications process data. Data comes in, data is processed, and then data goes out.

Data usually comes into our program from files, databases, or user input, and it can be put temporarily into variables that will be stored in the memory of the running program. When the program ends, the data in memory is lost. Data is usually output to files and databases, or to the screen or a printer. When using variables, you should think about, firstly, how much space the variable takes in the memory, and, secondly, how fast it can be processed.

We control this by picking an appropriate type. You can think of simple common types such as ``int`` and ``double`` as being different-sized storage boxes, where a smaller box would take less memory but may not be as fast at being processed; for example, adding 16-bit numbers might not be processed as fast as adding 64-bit numbers on a 64-bit operating system. Some of these boxes may be stacked close by, and some may be thrown into a big heap further away.

## Naming things and assigning values

There are naming conventions for things, and it is good practice to follow them.

Camel case - cost, orderDetail, dateOfBirth - for Local variables, private fields

Title case aka Pascal case - String, Int32, Cost, DateOfBirth, Run - Types, non-private fields, and other members like methods.

Creating and using local variables.

```csharp
    // let the heightInMetres variable become equal to the value 1.88
    double heightInMetres = 1.88;

    Console.WriteLine($"The variable {nameof(heightInMetres)} has the value {heightInMetres}.");
```

> The variable heightInMetres has the value 1.88.

## Literal values

When you assign to a variable, you often, but not always, assign a literal value. But what is a literal value? A literal is a notation that represents a fixed value. Data types have different notations for their literal values.

For text, multiple letters, such as Bob, are stored as a string type and are assigned using double quotes around the literal value, or assigning the return value of a function call, as shown in the following code:

```csharp
    string firstName = "Bob"; // assigning literal strings
    string lastName = "Smith";
    string phoneNumber = "(215) 555-4256";

    // assigning a string returned from a fictitious function
    string address = GetAddressFromDatabase(id: 563);
```

## Understanding verbatim strings

When storing text in a string variable, you can include escape sequences, which represent special characters like tabs and new lines using a backslash, as shown in the following code:

```csharp
    string fullNameWithTabSeparator = "Bob\tSmith";
```

But what if you are storing the path to a file on Windows, and one of the folder names starts with a T, as shown in the following code?

```csharp
    string filePath = "C:\televisions\sony\bravia.txt";
```

The compiler will convert the \t into a tab character and you will get errors!

You must prefix with the @ symbol to use a verbatim literal string, as shown in the following code:

```csharp
    string filePath = @"C:\televisions\sony\bravia.txt";
```

To summarise:

* **Literal string**: Characters enclosed in double-quote characters. They can use escape characters like \t for tab. To represent a backslash, use two: \\.
* **Verbatim string**: A literal string prefixed with @ to disable escape characters so that a backslash is a backslash. It also allows the string value to span multiple lines because the white space characters are treated as themselves instead of instructions to the compiler.
* **Interpolated string**: A literal string prefixed with $ to enable embedded formatted variables. You will learn more about this later.

## Storing numbers

Numbers are data that we want to perform an arithmetic calculation on, for example, multiplying. A telephone number is not a number. To decide whether a variable should be stored as a number or not, ask yourself whether you need to perform arithmetic operations on the number or whether the number includes non-digit characters such as parentheses or
hyphens to format the number, such as (414) 555-1234. In this case, the number is a sequence of characters, so it should be stored as a string.

Numbers can be natural numbers, such as **42**, used for counting (also called whole numbers); they can also be negative numbers, such as *-42* (called integers); or, they can be real numbers, such as **3.9** (with a fractional part), which are called single- or double-precision floating-point numbers in computing.

Let's explore numbers:

```csharp
    // unsigned integer means positive whole number or 0
    uint naturalNumber = 23;

    // integer means negative or positive whole number or 0
    int integerNumber = -23;

    // float means single-precision floating point
    // F suffix makes it a float literal
    float realNumber = 2.3F;
    
    // double means double-precision floating point
    double anotherRealNumber = 2.3; // double literal
```

## Improving legibility by using digit separators

Two of the improvements seen in C# 7.0 and later are the use of the underscore character _ as a digit separator, and support for binary literals.

You can insert underscores anywhere into the digits of a number literal, including decimal, binary, or hexadecimal notation, to improve legibility.

```csharp
    // three variables that store the number 2 million
    int decimalNotation = 2_000_000;
    int binaryNotation = 0b_0001_1110_1000_0100_1000_0000;
    int hexadecimalNotation = 0x_001E_8480;
```

## Storing real numbers

Computers cannot always represent real, aka decimal or non-integer, numbers precisely. The float and double types store real numbers using single- and double-precision floating points.

## Writing code to explore number sizes

C# has an operator named ``sizeof()`` that returns the number of bytes that a type uses in memory. Some types have members named ``MinValue`` and ``MaxValue``, which return the minimum and maximum values that can be stored in a variable of that type. We are now going to use these features to create a console application to explore number types:

```csharp
Console.WriteLine($"int uses {sizeof(int)} bytes and can store numbers in the range {int.MinValue:N0} to {int.MaxValue:N0}.");
Console.WriteLine($"double uses {sizeof(double)} bytes and can store numbers in the range {double.MinValue:N0} to {double.MaxValue:N0}.");
Console.WriteLine($"decimal uses {sizeof(decimal)} bytes and can store numbers in the range {decimal.MinValue:N0} to {decimal.MaxValue:N0}.");
```

Results:

> int uses 4 bytes and can store numbers in the range -2,147,483,648 to 2,147,483,647.      
> double uses 8 bytes and can store numbers in the range -179,769,313,486,231,570,814,527,423,731,704,356,798,070,567,525,844,996,598,917,476,803,157,260,780,028,538,760,589,558,632,766,878,171,540,458,953,514,382,464,234,321,326,889,464,182,768,467,546,703,537,516,986,049,910,576,551,282,076,245,490,090,389,328,944,075,868,508,455,133,942,304,583,236,903,222,948,165,808,559,332,123,348,274,797,826,204,144,723,168,738,177,180,919,299,881,250,404,026,184,124,858,368 to 179,769,313,486,231,570,814,527,423,731,704,356,798,070,567,525,844,996,598,917,476,803,157,260,780,028,538,760,589,558,632,766,878,171,540,458,953,514,382,464,234,321,326,889,464,182,768,467,546,703,537,516,986,049,910,576,551,282,076,245,490,090,389,328,944,075,868,508,455,133,942,304,583,236,903,222,948,165,808,559,332,123,348,274,797,826,204,144,723,168,738,177,180,919,299,881,250,404,026,184,124,858,368.       
> decimal uses 16 bytes and can store numbers in the range -79,228,162,514,264,337,593,543,950,335 to 79,228,162,514,264,337,593,543,950,335.

An int variable uses four bytes of memory and can store positive or negative numbers up to about 2 billion. A double variable uses eight bytes of memory and can store much bigger values! A decimal variable uses 16 bytes of memory and can store big numbers, but not as big as a double type.

But you may be asking yourself, why might a double variable be able to store bigger numbers than a decimal variable, yet it's only using half the space in memory?

The double type is not guaranteed to be accurate because some numbers like 0.1 literally cannot be represented as floating-point values.

As a rule of thumb, you should only use double when accuracy, especially when comparing the equality of two numbers, is not important. An example of this may be when you're measuring a person's height and you will only compare values using greater than or less than, but never equals.

The decimal type is accurate because it stores the number as a large integer and shifts the decimal point. For example, 0.1 is stored as 1, with a note to shift the decimal point one place to the left. 12.75 is stored as 1275, with a note to shift the decimal point two places to the left.

**Good Practice:** Use int for whole numbers. Use double for real numbers that will not be compared for equality to other values; it is okay to compare double values being less than or greater than, and so on. Use decimal for money,
CAD drawings, general engineering, and wherever the accuracy of a real number is important.

## Storing Booleans

Booleans can only contain one of the two literal values true or false, as shown in the following code:

```csharp
    bool happy = true;
    bool sad = false;
```

They are most commonly used to branch and loop.

## Storing any type of object
